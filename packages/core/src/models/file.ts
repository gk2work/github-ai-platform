import { FileInfo, Language } from '@github-ai/shared';

export interface EnhancedFileInfo extends FileInfo {
  // Additional metadata
  encoding: string;
  hash: string; // For change detection
  
  // Content analysis
  isEmpty: boolean;
  isGenerated: boolean; // Auto-generated files
  hasTests: boolean;
  
  // Structure analysis
  imports: ImportInfo[];
  exports: ExportInfo[];
  functions: FunctionInfo[];
  classes: ClassInfo[];
  
  // Metrics (calculated during analysis)
  cyclomaticComplexity: number;
  cognitiveComplexity: number;
  maintainabilityIndex: number;
  
  // Issues found
  issues: FileIssue[];
  
  // Analysis metadata
  analyzedAt: Date;
  analysisVersion: string;
}

export interface ImportInfo {
  module: string;
  type: 'default' | 'named' | 'namespace' | 'side-effect';
  imports: string[];
  line: number;
}

export interface ExportInfo {
  name: string;
  type: 'default' | 'named' | 'namespace';
  line: number;
}

export interface FunctionInfo {
  name: string;
  line: number;
  endLine: number;
  parameters: number;
  complexity: number;
  isAsync: boolean;
  isExported: boolean;
}

export interface ClassInfo {
  name: string;
  line: number;
  endLine: number;
  methods: FunctionInfo[];
  properties: number;
  isExported: boolean;
}

export interface FileIssue {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  line: number;
  column?: number;
  rule: string;
  fixable: boolean;
  suggestion?: string;
}

export class FileProcessor {
  /**
   * Convert basic FileInfo to EnhancedFileInfo with additional metadata
   */
  static enhance(fileInfo: FileInfo, content: string): EnhancedFileInfo {
    const enhanced: EnhancedFileInfo = {
      ...fileInfo,
      encoding: 'utf-8',
      hash: this.calculateHash(content),
      isEmpty: content.trim().length === 0,
      isGenerated: this.isGeneratedFile(fileInfo.path, content),
      hasTests: this.hasTestContent(content),
      imports: [],
      exports: [],
      functions: [],
      classes: [],
      cyclomaticComplexity: 0,
      cognitiveComplexity: 0,
      maintainabilityIndex: 100,
      issues: [],
      analyzedAt: new Date(),
      analysisVersion: '1.0.0'
    };

    return enhanced;
  }

  /**
   * Calculate a simple hash for content change detection
   */
  private static calculateHash(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(16);
  }

  /**
   * Check if a file is auto-generated
   */
  private static isGeneratedFile(filePath: string, content: string): boolean {
    // Check file patterns
    const generatedPatterns = [
      /\.generated\./,
      /\.g\./,
      /\.min\./,
      /_pb\./,
      /\.proto\./
    ];

    if (generatedPatterns.some(pattern => pattern.test(filePath))) {
      return true;
    }

    // Check content patterns
    const generatedContentPatterns = [
      /This file was automatically generated/i,
      /Do not edit this file/i,
      /Auto-generated/i,
      /@generated/,
      /Code generated by/i
    ];

    return generatedContentPatterns.some(pattern => pattern.test(content));
  }

  /**
   * Check if file contains test content
   */
  private static hasTestContent(content: string): boolean {
    const testPatterns = [
      /describe\s*\(/,
      /it\s*\(/,
      /test\s*\(/,
      /expect\s*\(/,
      /assert\./,
      /setUp|tearDown/,
      /@Test/,
      /def test_/
    ];

    return testPatterns.some(pattern => pattern.test(content));
  }
}
